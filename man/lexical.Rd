% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lexical.R
\name{lexical}
\alias{let}
\alias{let.star}
\alias{letrec}
\alias{lexical}
\title{Lexical binding constructs}
\usage{
let(bindings, ...)

let.star(bindings, ...)

letrec(bindings, ...)
}
\arguments{
\item{bindings}{A list whose elements are themselves two element lists: the
first element of each is a symbol, the second the value the symbol should be
bound to in the environment for evaluating the body statements.}

\item{...}{Body statements.}
}
\value{
The result of evaluating the final body expression.
}
\description{
These functions provide the let, let* and letrec block-scope operators
from Scheme. All three of them create temporary variables with specified
values, successively evaluate provided body expressions, and return the
value of the last expression.
}
\details{
All three forms are syntactically identical:

\code{
.(LET_OP, .(.(variable, init) ...), expr, expr ...)
}

where LET_OP is \code{let}, \code{let.star} or \code{letrec}.

They differ in the scope in which the temporary bindings (of names to init
expressions' values) exist:
\itemize{
\item{let computes the init expressions before creating any bindings.}
\item{let.star creates the bindings, and in the process evaluates the init
expressions, sequentially left to right, so that earlier bindings are in
scope for evaluating later init expressions.}
\item{letrec evaluates all init expressions simultaneously, with all
bindings in scope during evaluation. (The init expressions can therefore
be mutually recursive.)}
}
}
\section{Note}{

R, unlike Scheme, does not have a notion of variable definition separate
from assignment. So the init expressions are mandatory here, whereas in
Scheme it is possible to create uninitialized variables in the scope of the
body block.

The let, let.star and letrec functions take arguments in a way that seems
natural in \code{\link{prefix}} notation, but makes for odd-looking calls
in the usual infix form. Calling them "directly" - i.e., other than through
prefix code and SchemeR() or infix() - is not recommended.
}
\examples{
schemeR::schemeR({
.(let, .(.(i, 3),
        .(foo, 5)),
   .(`==`, i, .(`-`, foo, 2)))
 }, pkg=TRUE) == TRUE
schemeR::schemeR({
.(let.star, .(.(i, 3), .(foo, 5)),
      .(`==`, i,
              .(`-`, foo, 2)))
 }, pkg=TRUE) == TRUE
schemeR::schemeR({
.(letrec, .(.(i, 3), .(foo, 5)),
     .(`==`, i,
             .(`-`, foo, 2)))
 }, pkg=TRUE) == TRUE

schemeR::schemeR({
.(letrec, .(.(i, 3),
            .(foo, .(lambda, .(n), .(`+`, n, 1)))),
     .(`==`, i, .(foo, 2)))
 }, pkg=TRUE) == TRUE
}

