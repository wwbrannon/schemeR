% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/flow-control.R
\name{flow-control}
\alias{and}
\alias{case}
\alias{cond}
\alias{do}
\alias{flow-control}
\alias{or}
\title{Flow-control operators}
\usage{
or(...)

and(...)

case(...)

cond(...)

do(...)
}
\arguments{
\item{...}{The infix form of prefix arguments. Note that for \code{and()}
and \code{or()}, each element of ... is just an arbitrary R expression.}
}
\value{
Return values are different for different operators.
\itemize{
\item{or returns the value of the first expression which when
coerced to logical is TRUE, or otherwise returns FALSE;}
\item{and returns the value of the first expression which when
coerced to logical is FALSE, or otherwise returns TRUE;}
\item{case returns the value of the expression associated with its key
expression's value, or if the key's value was not in any clause, returns
NULL;}
\item{cond returns the value of the last expression in the list of them
associated with the first clause whose test condition was logically TRUE,
or if no condition was TRUE, returns NULL;}
\item{do returns the value of the expression provided with its test
expression on the first iteration on which the test expression is logically
TRUE (if no second expression was provided, the value of the test expression
is returned).}
}
}
\description{
These functions provide R versions of several Scheme flow-control operators.
\code{cond()} and \code{case()} are conditional forms, \code{do()} is an
iteration construct, and \code{or()} and \code{and()} allow for conditional
short-circuit evaluation. See the vignettes for full details and a more
in-depth discussion of how to use these operators.
}
\examples{
# the print("foo") clause will never be reached in either expression
schemeR::schemeR({
.(or, 1==2, TRUE, print("foo"))
.(and, 1==1, 3 > 4, print("foo"))
 }, pkg=TRUE)

schemeR::schemeR({
.(case, .(`+`, 1, 1),
  .(3, .(print, "foo")),
  .(2, .(print, "bar")))
 }, pkg=TRUE)
schemeR::schemeR({
.(cond,
  .(.(`==`, .(`+`, 1, 4), 4), .(print, "foo")),
  .(.(`==`, .(`+`, 1, 3), 5), .(print, "bar")),
  .(TRUE, .(print, "baz")))
 }, pkg=TRUE)
schemeR::schemeR({
.(let, .(.(x, .(c, 1, 3, 5, 7, 9))),
  .(do, .(.(x, .(c, 1, 3, 5, 7, 9), .(cdr, x)),
          .(s, 0, .(`+`, s, .(car, x))),
          .(foo, 4)),
    .(.(is.nil, x), s),
    TRUE)) #=> 25
 }, pkg=TRUE)
}

