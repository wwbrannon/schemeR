% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prefix.R
\name{prefix}
\alias{.}
\alias{infix}
\alias{prefix}
\title{Facilities for writing R code in prefix notation}
\usage{
prefix(expr)

infix(expr)

.(f, ...)
}
\arguments{
\item{expr}{A prefix- or infix-formatted expression to convert. Code between
"R(" and ")" will not be converted.}

\item{f}{The function that \code{.} should generate a call to.}

\item{...}{Further arguments to the function f.}
}
\value{
\code{prefix} and \code{infix} return the input expression
converted to prefix or infix.

\code{.} returns an unevaluated call to f with \code{...} arguments
carried through.
}
\description{
The \code{.} function allows writing an R function call in a Lisp-like
prefix format, rather than the Algol-like infix format that R usually
uses. \code{prefix} and \code{infix} convert R code between infix and
prefix.
}
\details{
When evaluated, a call to \code{.} doesn't actually execute the function
that's been expressed in prefix style, just generates the corresponding
infix call. It's intended as a notational aid, so that entire scripts
can be written in the prefix form.

A call to \code{prefix()} does not evaluate the passed
or the generated expressions, partly for efficiency reasons; \code{infix()},
though it still does not evaluate the generated expression, does do
partial evaluation of the passed expression: each call to \code{.} is
evaluated to the corresponding infix call.

\code{infix} and \code{prefix} are not quite inverses of each other, because
\code{infix} understands certain pieces of infix syntactic sugar. Examples
include the ".q" and ".b" quoting abbreviations, and the lambda lists passed
to \code{lambda}, \code{macro} and \code{defmacro}.
}
\examples{
prefix(expression(x <- runif(10), y <- runif(10), cor(x, y)))

prefix(expression(with(datasets::iris, sum(Sepal.Length^2 + Petal.Width))))


infix(expression(.(`<-`, x, .(runif, 10)), .(`<-`, y, .(runif, 10)),
                 .(cor, x, y)))

infix(expression(.(with, .(`::`, datasets, iris),
                             .(sum, .(`+`, .(`^`, Sepal.Length, 2),
                                           Petal.Width)))))
.(`+`, 1, 2)

.(sum, .(runif, 10), .(runif, 10))

}

