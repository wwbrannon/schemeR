% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/schemeR.R
\docType{package}
\name{schemeR-package}
\alias{schemeR-package}
\title{schemeR: Make R more like Lisp/Scheme}
\description{
Provides a way to write R code in a Lisp-like \code{\link{prefix}} form,
with access to versions of many common Lisp operators (let, letrec, cond,
do, etc.). True Lisp macros are also supported and are optimized to work
with this sort of prefix code.
}
\section{Interface functions}{

The main entry point is the \code{schemeR()} function, which translates
prefix code into the usual infix R form, and evaluates it. Other functions
involved in implementing the prefix syntax are \code{prefix()} and
\code{infix()}, which respectively translate infix code \strong{to} prefix,
and translate prefix code \strong{to} infix. The \code{.} function is the
building block of prefix code, but is not especially useful in its own
right.
}

\section{Lisp operators}{

A large number of Lisp operators have been implemented, mostly in ways that
are useful in either prefix or infix code. The highlight is the reasonably
complete \code{\link{macro}} support, but other operators run the gamut from
functional programming primitives (\code{lambda}, \code{zip},
\code{for.each}, etc.) to list/vector manipulation (\code{car}, \code{cdr},
\code{set.car}, etc.) to block-structure and lexical binding operators
(\code{let}, \code{letrec}, \code{cond}, etc.). See \code{\link{functions}}
for a full list and discussion.
}

